## 浏览器向服务器请求数据
#### 浏览器如何获取到数据？






#### 浏览器缓存
缓存分为：客户端缓存、服务端缓存、代理服务器缓存等



#### 浏览器获取到数据后的解析（浏览器的渲染原理）

























### 单线程
### 同步和异步
### 事件机制
在浏览器中，JavaScript与其他N中任务共享一个线程。通常情况下JavaScript与绘制、更新样式和处理用户操作（例如，高亮显示文本）处于同一个队列。操作其中一项任务会延迟其他任务。
1. 主线程 （主线程通过事件循环过程去取消息）
2. 消息队列
   消息就是注册异步任务时添加的回调函数
3. 工作线程 （将消息放到消息队列）






setTimeout的等待时间取决于事件队列里待处理的消息数量




### 从输入url到页面加载的过程发生了什么？
    总体来说分为以下几个过程：
1. DNS解析
   DNS解析的过程就是寻找那个机器上有你需要资源的过程。DNS解析是一个递归查询的过程。
   1.1 DNS优化
   1.2 DNS缓存
       DNS存在多级缓存，从离浏览器的距离排序和话，有一下几种：浏览器缓存、系统缓存（主要存在Linux系统中）、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存
   1.3 DNS负载均衡（又叫DNS重定向）
       根据每台机器的负载量和机器离用户地理位置的距离等等，返回一个合适的机器ip给用户。
2. TCP链接  （tcp协议是传输层协议，tcp三次握手？）
   TCP连接具有三个阶段： 连接建立、数据传送以及连接释放。
   连接建立阶段：
       第一次握手：客户端的应用进程主动打开，并向服务端发送请求报文段。其首部中： SYN=1,seq=x
       第二次握手：服务器应用进程主动打开。若同意客户端请求，则发回确认报文。
       第三次握手：客户端收到确认报文后，通知上层应用进程连接已建立，并向服务器发出确认报文。当服务器收到客户端的确认报文后，也通知上层应用进程连接已建立。
   连接释放阶段：
       第一次握手：数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据。
       第二次握手：服务器端收到连接释放报文段后，发出确认报文，此时本次连接进入半关闭状态，客户端不在发送数据。而服务端仍会继续发送
       第三次握手：若服务器已经没有要向客户端发送的数据，其应用进程就通知服务器释放tcp连接。
       第四次握手：客户端收到连接释放报文段之后，必须发出确认。本次TCP连接真正的结束，通信双方完成了他们的告别。    
3. 发送http请求 （http头部;http缓存；http2.0）
   http请求由三部分组成：请求行、请求报头和请求正文
   请求报头：Accept(用于指定客户端接收那些类型的信息)、Accept-Encoding（用于指定接受的编码方式）、Connection(设置为keep-alive用户告诉客户端本次http请求结束之后并不需要关闭tcp连接)、Accept-Language(用户指定接受什么类型的语言)和cookie等等。
4. 服务器处理请求并返回HTTP报文
   HTTP的响应报文由三部分组成：状态码、响应报头和响应报文。
5. 浏览器解析渲染页面 （浏览器的工作原理；浏览器事件循环Event loop;回流和重绘）
   5.1 浏览器解析HTML文件构建DOM树
   5.2 解析css文件构建渲染树
   5.3 浏览器开始布局渲染树并将其绘制的屏幕上。
   
   回流必将引起重绘，而重绘不一定引起回流
   回流：当render tree中一部分因为元素的规模尺寸、布局、隐藏等改变而需要重新构建。
   重绘：当render tree中的一些元素需要更新属性，而这些元素只是影响元素的外观和风格，而不会影响布局。
   
   HTML页面的生命周期有以下三个重要事件：
   1. DOMContentLoaded ----------- 浏览器已经完全加载了HTML,DOM树已经构建完毕，但是像是<img>和样式表等外部资源可能并没有下载完毕。
   2. load --------- 浏览器已经加载了所有资源（图像、样式表等）。
   3. beforeunload/unload ------ 当用户离开页面的时候触发的。

   每个事件都有特定的用途：
   1. DOMContentLoaded ------- DOM加载完毕，JS可以访问所有DOM节点，初始化界面。
   2. Load ------- 附加资源已经加载完毕，可以在此事件触发时获得图像的大小。
   3. beforeunload/unload ------ 用户正在离开页面，可以访问用户是否保存了更改以及是否确定要离开页面。
   load、DOMContentLoaded事件的触发顺序：
   Event Loop:
      宏任务： setTimout、setInterval、script、setImmediate、I/O、UI rendering
      微任务： promise（new promise立即执行但是then会放到微任务列表中）、 process.nextTick（没有立即执行，直接放到微任务列表中）
      js是单线程运行。js的执行机制可以看做是一个主线程加一个任务队列。同步任务放在主线程上执行，异步任务放在任务队列中。
6. 连接结束    






### webpack
webpack可以看做是模板打包机；他做的事情是，分析你的目录结构，找到JavaScript模块以及其他的一些浏览器不能直接运行的扩展语言（scss, typescript等），并将其转换和打包为合适的格式供浏览器使用。
1. 引入对应文件的模块解析。例如：vue-loader,babel-loader,css-loader等
2. 提取css为外部引入，通过link引入
3. 文件压缩
4. 大文件拆分
5. 公共文件提取为独立文件
6. 通过html-webpack-plugin将所有依赖的js/css等静态资源注入模板文件，生成目标文件保存到指定服务器模板文件目录。

Grunt和gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译、组合和压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。
webpack的工作方式是： 把你的项目当做一个整体，通过一个给定的主文件（main.js），webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。

Loaders: 通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css。
loaders需要单独安装并且需要在webpack.config.js中modules关键字下进行配置，loaders的配置包括以下几方面：
1. test: 一个用以匹配loaders所处理文件的扩展名的正式表达式（必须）
2. loader: loader的名称（必须）
3. include/exclude： 手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）
4. query：为loaders提供额外的设置选项（可选）

Babel: 一个编译JavaScript的平台。
### 异步方法
1. callBack: 是一个函数，会作为一个参数传递到另一个函数中，并稍后去执行。（callback处理回调可能产生调用过早、调用过晚等问题）
jquery的ajax获取数据是
$.get(url, (data) => {console.log(data)})
2. 事件监听
3. 发布/订阅
4. promise：promise是一个构造函数，new promise返回一个promise对象接收一个excutor执行函数作为参数，excutor有两个函数类型形参resolve 和 reject

5. async---await


### 前端性能优化
1. 合并请求(减少http请求)：主要目的减少浏览器对服务器发起请求，从而减少在在发起请求过程中花费的时间。（合并js、合并css及合并小图片）
2. 域名拆分： 主要是为了增加浏览器下载的并行度，让浏览器能同时发起更多的请求。
3. 开启Gzip： 将资源在服务端进行压缩，然后发送给服务器后再进行解压，这种方式会降低传输大小，提高网页加载性能。
4. 开启keep-alive（http请求头部---connection: keep-alive）：能够减少浏览器与服务器建立连接的次数（tcp连接），从而节省建立连接的时间。
5. Minify: 指的是将JS和css等文本文件进行最小化处理，一般对于css来说就是去除空格去除换行去除注释等。
6. 图片懒加载。 vue-lazyload

### 设计模式
1. 观察者模式
2. 发布-订阅模式（vue数据双向绑定）


### 浏览器跨域问题
1. 同源策略： 端口号、域名、协议相同。同源策略限制下cookie、localstorage、dom、ajax、indexDB都是不支持跨域的。
2. 跨域是什么？ 在同源策略的限制下，可以访问后台服务器的数据，后台服务器会正常返回数据，而被浏览器给拦截了。
3. 解决跨域的方法？
   3.1 jsonp（只发送get请求）： jsonp最基本的原理是动态添加一个<script>标签，而script标签的src属性是没有跨域限制的。这样来说，这种跨域方式其实与ajax XmlHttpRequest协议无关了。JSONP是一种脚本注入行为，所以有一定的安全隐患。post动态生成iframe是可以达到post跨域的目的。打这样做比较极端，不建议采用。
   3.2 CORS： 使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或相应是否成功。设置Access-Control-Allow-Origin参数，即那个源可以访问服务器。
   3.3 postMessage: H5的新API，来自不同域的页面间传递消息。不是使用Ajax的数据通信，更多在iframe页面嵌套时，两个页面之间通信。onmessage监听，postMessage发送数据
   3.4 Window.name:  使用iframe，不同域的页面之间参数传递。在被嵌入的页面设置window.name属性值。
   3.5 location.hash： 使用iframe，不同域的页面之间参数传递。
   3.6 websocket： 没有跨域限制，websocket与http内部都是基于TCP协议，区别在与HTTP是单向的（单双工），websocket是双向的（全双工）。
   3.7 nginx



### 执行上下文
执行上下文分为：全局执行上下文、函数执行上下文、eval执行上下文
每一个执行上下文包含三部分：
1. 变量对象（变量声明提升的问题）
2. 作用域链;
3. this;（this指向问题？call、apply、bind;箭头函数自身没有this， this指向调用它的第一个函数的this）


### 事件委托(又叫事件代理)
利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。

事件冒泡：就是事件从最深的节点开始，然后逐步向上传播事件。

### vue-lazyloader原理
vue-lazyloader实现图片的懒加载。
懒加载的原理：首先将页面上的图片的src属性设为空字符串，而图片的真实路径则设置在data-orininal属性中，当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区如果图片在可视区内将图片的src属性设置为data-original的值，这样就可以实现懒加载原理。

vue-lazyloader实现懒加载的原理：   
1. vue-lazyload是通过指令的方式实现的，定义的指令是v-lazy指令
2. 指令被bind是会创建一个listener，并将其添加到listener queue里面，并且搜索target dom节点，为其注册dom事件（如scroll事件）
3. 上面的dom事件回调中，会遍历listener queue的listener，判断此时绑定的dom是否处于页面中的perload的位置，如果在则异步加载当前图片资源
4. 同时listener会在当前图片加载的过程中loading、load、error三种状态触发当前dom渲染的函数


### 前端鉴权（权限管理）
1. Token验证

### 函数防抖和函数节流


### BFC


### 继承
一、 原型及原型链
#### 原型
Javascript并非是基于类的继承，而是基于原型的继承。
二、 继承的几种方式